"""
Email Summarizer Models - Lean & Optimized Design
Following the existing model patterns for consistency
"""

from app import db
from datetime import datetime
from sqlalchemy.dialects.postgresql import ARRAY, JSONB
from sqlalchemy import Index

# ======================
# CORE TABLES (3 TABLES ONLY)
# ======================

class EmailAccount(db.Model):
    """
    Stores user's Gmail OAuth tokens
    Reuses existing Google Auth credentials
    """
    __tablename__ = 'email_accounts'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.String(36), db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False, unique=True)
    email_address = db.Column(db.String(255), nullable=False)
    
    # OAuth tokens (encrypted in production)
    access_token = db.Column(db.Text)
    refresh_token = db.Column(db.Text)
    token_expires_at = db.Column(db.DateTime)
    
    # Sync tracking
    last_sync_at = db.Column(db.DateTime)
    sync_token = db.Column(db.String(255))  # Gmail history ID for incremental sync
    
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    user = db.relationship('User', backref=db.backref('email_account', uselist=False, cascade='all, delete-orphan'))
    emails = db.relationship('Email', backref='account', lazy='dynamic', cascade='all, delete-orphan')

    def __repr__(self):
        return f'<EmailAccount {self.email_address}>'

    def to_dict(self):
        return {
            'id': self.id,
            'email_address': self.email_address,
            'last_sync_at': self.last_sync_at.isoformat() if self.last_sync_at else None,
            'is_active': self.is_active
        }


class Email(db.Model):
    """
    Stores minimal email metadata for display
    AI categorizes on-the-fly, no separate category table
    """
    __tablename__ = 'emails'
    __table_args__ = (
        Index('idx_email_account', 'account_id'),
        Index('idx_email_date', 'email_date'),
        Index('idx_email_category', 'category'),
        Index('idx_email_starred', 'is_starred'),
    )

    id = db.Column(db.Integer, primary_key=True)
    account_id = db.Column(db.Integer, db.ForeignKey('email_accounts.id', ondelete='CASCADE'), nullable=False)
    
    # Gmail identifiers
    message_id = db.Column(db.String(255), unique=True, nullable=False)
    thread_id = db.Column(db.String(255))
    
    # Display metadata
    subject = db.Column(db.Text)
    sender_email = db.Column(db.String(255), nullable=False)
    sender_name = db.Column(db.String(255))
    snippet = db.Column(db.Text)  # 160 char preview from Gmail
    
    # Simple category (AI-assigned or user-changed)
    # Categories: important, work, personal, finance, shopping, promotions, spam, other
    category = db.Column(db.String(32), default='other')
    
    # User actions
    is_starred = db.Column(db.Boolean, default=False)
    is_read = db.Column(db.Boolean, default=False)
    has_attachments = db.Column(db.Boolean, default=False)
    
    # Timestamps
    email_date = db.Column(db.DateTime, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # Relationships
    summary = db.relationship('EmailSummary', backref='email', uselist=False, cascade='all, delete-orphan')

    def __repr__(self):
        return f'<Email {self.subject[:30]}...>'

    def to_dict(self):
        return {
            'id': self.id,
            'message_id': self.message_id,
            'subject': self.subject,
            'sender_email': self.sender_email,
            'sender_name': self.sender_name,
            'snippet': self.snippet,
            'category': self.category,
            'is_starred': self.is_starred,
            'is_read': self.is_read,
            'has_attachments': self.has_attachments,
            'email_date': self.email_date.isoformat() if self.email_date else None,
            'has_summary': self.summary is not None
        }


class EmailSummary(db.Model):
    """
    Stores AI-generated summaries (created on-demand)
    Simple structure - just the essentials
    """
    __tablename__ = 'email_summaries'

    id = db.Column(db.Integer, primary_key=True)
    email_id = db.Column(db.Integer, db.ForeignKey('emails.id', ondelete='CASCADE'), unique=True, nullable=False)
    
    # Summary content (generated by AI)
    summary_text = db.Column(db.Text, nullable=False)  # 2-3 sentences
    key_points = db.Column(ARRAY(db.String))  # 3-5 bullet points
    action_items = db.Column(ARRAY(db.String))  # Extracted tasks/actions
    
    # Metadata
    priority = db.Column(db.String(16), default='medium')  # low, medium, high, urgent
    sentiment = db.Column(db.String(16))  # positive, neutral, negative
    
    # AI info (for debugging/improvements)
    model_used = db.Column(db.String(32))  # e.g., 'gpt-4o-mini'
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<EmailSummary {self.email_id}>'

    def to_dict(self):
        return {
            'id': self.id,
            'summary_text': self.summary_text,
            'key_points': self.key_points,
            'action_items': self.action_items,
            'priority': self.priority,
            'sentiment': self.sentiment,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }


# ======================
# CATEGORY CONSTANTS (No separate table needed)
# ======================

EMAIL_CATEGORIES = {
    'important': {'name': 'Important', 'color': '#FF5252', 'icon': 'star'},
    'work': {'name': 'Work', 'color': '#2196F3', 'icon': 'work'},
    'personal': {'name': 'Personal', 'color': '#4CAF50', 'icon': 'person'},
    'finance': {'name': 'Finance', 'color': '#FFC107', 'icon': 'attach_money'},
    'shopping': {'name': 'Shopping', 'color': '#9C27B0', 'icon': 'shopping_cart'},
    'promotions': {'name': 'Promotions', 'color': '#00BCD4', 'icon': 'local_offer'},
    'spam': {'name': 'Spam', 'color': '#F44336', 'icon': 'report'},
    'other': {'name': 'Other', 'color': '#9E9E9E', 'icon': 'folder'}
}


# ======================
# HELPER FUNCTIONS
# ======================

def get_category_info(category_slug):
    """Get category display information"""
    return EMAIL_CATEGORIES.get(category_slug, EMAIL_CATEGORIES['other'])


def get_all_categories():
    """Get all available categories"""
    return [
        {
            'slug': slug,
            'name': info['name'],
            'color': info['color'],
            'icon': info['icon']
        }
        for slug, info in EMAIL_CATEGORIES.items()
    ]